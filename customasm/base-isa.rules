#subruledef register
{
    r{reg: u3} => reg
}
#subruledef computation
{
    add => 0x0
    sub => 0x1
    rsub => 0x2
    comp => 0x3
    cmp => 0x3

    xor => 0x4
    or => 0x5
    and => 0x6
    test => 0x7

    mov => 0x8

    load => 0xA
    ld => 0xA
    store => 0xB
    st => 0xB

    slo => 0xC

    port_read => 0xE
    port_write => 0xF

}

#subruledef jump_name
{
    jump_zero => 0x0
    jump_equal => 0x0
    jz => 0x0
    je => 0x0
    jeq => 0x0

    jump_not_zero => 0x1
    jump_not_equal => 0x1
    jnz => 0x1
    jne => 0x1

    jump_negative => 0x2
    jn => 0x2

    jump_not_negative => 0x3
    jnn => 0x3

    jump_carry => 0x4
    jump_below => 0x4
    jc => 0x4
    jb => 0x4

    jump_not_carry => 0x5
    jump_above_or_equal => 0x5
    jnc => 0x5
    jae => 0x5

    jump_overflow => 0x6
    jo => 0x6

    jump_not_overflow => 0x7
    jno => 0x7

    jump_below_or_equal => 0x8
    jbe => 0x8

    jump_above => 0x9
    ja => 0x9

    jump_less => 0xA
    jl => 0xA
    jlt => 0xA

    jump_greater_or_equal => 0xB
    jge => 0xB

    jump_less_or_equal => 0xC
    jle => 0xC

    jump_greater => 0xD
    jg => 0xD
    jgt => 0xD

    jump => 0xE
    jmp => 0xE

    jump_never => 0xF
    nop => 0xF
}

#subruledef control_register
{
    cpuid => 0`4
    exten => 1`4
    cr{c: u4} => c
}


#ruledef
{
    {opcode: computation} {target: register}, {value: register} =>
        {
            assert(opcode < 0b1100),
            0b00 @ 0b01 @ opcode @ target @ value @ 0b00
        }
    {opcode: computation} {target: register}, {value: i5} => 0b01 @ 0b01 @ opcode @ target @ value

    mov {target: register}, [{pointer: register}] => asm {load {target}, pointer}
    mov [{pointer: register}], {source: register} => asm {store {pointer}, {source}}
    mov {target: register}, [{pointer: s5}] => asm {load {target}, pointer}
    mov [{pointer: s5}], {source: register} => asm {store {pointer}, {source}}

    inp {target: register}, {port: u4} => asm {port_read {target}, port @ 0b1}
    out {source: register}, {port: u4} => asm {port_write {source}, port @ 0b1}

    mov {target: register}, {control: control_register} => asm {port_read {target}, control @ 0b0}
    mov {control: control_register}, {source: register} => asm {port_write {source}, control @ 0b0}
}

#ruledef
{
    {opcode: jump_name} {addr} =>
        {
            reladdr = addr - $
            assert(-256 <= reladdr)
            assert(reladdr < 256)
            0b10 @ 0b0 @ reladdr[8:8] @ opcode @ reladdr[7:0]
        }

    nop => asm {jump_never $}
    hlt => asm{jmp $}
}

#ruledef
{
    mov {target: register}, {value: s16} =>
        {
            (value[15:15] == value[14:14]) ?
                0b01 @ 0b01 @ 0x8 @ target @ value[14:10] @ asm {
                    slo {target}, value[9:5]
                    slo {target}, value[4:0]
                }
              : 0b01 @ 0b01 @ 0x8 @ target @ 0b0000 @ value[15:15] @ asm {
                    slo {target}, value[14:10]
                    slo {target}, value[9:5]
                    slo {target}, value[4:0]
              }
        }
}
