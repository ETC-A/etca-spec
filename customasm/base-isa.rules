#subruledef register
{
    r{reg: u3} => reg
}
#subruledef computation
{
    add => 0x0
    sub => 0x1
    rsub => 0x2
    comp => 0x2

    xor => 0x4
    or => 0x5
    and => 0x6
    test => 0x7

    mov => 0x8

    load => 0xA
    store => 0xB

    slo => 0xC

    port_read => 0xE
    port_write => 0xF

}

#subruledef jump_name
{
    jo => 0x0
    jno => 0x1

    js => 0x2
    jns => 0x3

    je => 0x4
    jne => 0x5

    jb => 0x6
    jae => 0x7

    jbe => 0x8
    ja => 0x9

    jl => 0xA
    jge => 0xB

    jle => 0xC
    jg => 0xD

    jump_never => 0xE
    jump => 0xF
}

#subruledef control_register
{
    cpuid => 0`4
    exten => 1`4
    cr{c: u4} => c
}


#ruledef
{
    {opcode: computation} {target: register}, {value: register} =>
        {
            assert(opcode < 0b1100),
            0b00 @ 0b01 @ opcode @ target @ value @ 0b00
        }
    {opcode: computation} {target: register}, {value: s5} => 0b01 @ 0b01 @ opcode @ target @ value

    mov {target: register}, [{pointer: register}] => asm {load {target}, pointer}
    mov [{pointer: register}], {source: register} => asm {store {pointer}, {source}}
    mov {target: register}, [{pointer: s5}] => asm {load {target}, pointer}
    mov [{pointer: s5}], {source: register} => asm {store {pointer}, {source}}

    inp {target: register}, {port: u4} => asm {port_read {target}, port @ 0b1}
    out {source: register}, {port: u4} => asm {port_write {source}, port @ 0b1}

    mov {target: register}, {control: control_register} => asm {port_read {target}, control @ 0b0}
    mov {control: control_register}, {source: register} => asm {port_write {source}, control @ 0b0}
}

#ruledef
{
    {opcode: jump_name} {addr} =>
        {
            reladdr = addr - $
            assert(-256 <= reladdr)
            assert(reladdr < 256)
            0b10 @ 0b0 @ reladdr[8:8] @ opcode @ reladdr[7:0]
        }

    nop => asm {jump_never $}
}