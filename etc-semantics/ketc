#!/usr/bin/env bash

set -euo pipefail
shopt -s extglob

debug=false
verbose=false
KETC=ketc

fatal() { echo "[FATAL] $@" >&2 ; exit 1 ; }

check_k_install() {
    which krun &> /dev/null \
        || fatal "Must have K installed! See https://github.com/kframework/k/releases."
}

INSTALL_BIN="$(cd "$(dirname "$0")" && pwd)"
INSTALL_LIB="$(dirname "${INSTALL_BIN}")/lib/${KETC}"
INSTALL_INCLUDE=${INSTALL_LIB}/include

export PATH="${INSTALL_BIN}:${INSTALL_LIB}:${PATH}"

run_kompile() {
    local kompile_opts
    
    kompile_opts=( "${run_file}" --backend "${backend}" --directory "${backend_dir}" )
    # This is needed to get `kpyk` to work on the definition for printing
    # However I'm leaving that disabled for now anyways because `kpyk print`
    # does not (currently) respect format attributes.
    # kompile_opts+=( --emit-json                               )

    kompile "${kompile_opts[@]}" "$@"
}

parse_binary_file() {
    hexdump -ve '"\\\x" 1/1 "%.2x"' "$1"
}

run_krun() {
    local cpgm ccpuid1 ccpuid2 cfeat parser

    check_k_install

    cpgm="\dv{SortBytes{}}(\"$(parse_binary_file ${run_file})\")"
    ccpuid1="\dv{SortInt{}}(\"${cpuid1}\")"
    ccpuid2="\dv{SortInt{}}(\"${cpuid2}\")"
    cfeat="\dv{SortInt{}}(\"${feat}\")"

    parser='cat'

    krun --directory "$backend_dir"            \
        -cPGM="$cpgm"       -pPGM="$parser"    \
        -cCPUID1="$ccpuid1" -pCPUID1="$parser" \
        -cCPUID2="$ccpuid2" -pCPUID2="$parser" \
        -cFEAT="$cfeat"     -pFEAT="$parser"   \
        "$@"
}

# Main
# ----------

if [[ $# -eq 0 ]] ; then
    set "help"
fi

run_command="$1" ; shift

if [[ "$run_command" == 'help' ]] || [[ "$run_command" == '--help' ]] ; then
    echo "
        usage: ${KETC} run     [--verbose|--debug] <${KETC} arg> <pgm>  <K arg>*
               ${KETC} kompile [--verbose|--debug]            <main> <K arg>*

               ${KETC} [help|--help|version|--version]
          
          ${KETC} run     : Run a single ETCa program.
          ${KETC} kompile : Run Kompile with the appropriate setup for ketc.
          ${KETC} help    : Display this help message.
          ${KETC} version : Display the versions of ketc and K in use.
          
          Note: <pgm> is a path to a file containing a raw binary ETCa program.
                <${KETC} arg> is one of [--mode (NORMAL|STRICT|EVIL)]
                                     [--backend (llvm|haskell)]
                                     [--cpuid <number>]
                                     [--debug]
                    The default is NORMAL mode, llvm backend, cpuid 0.
                <K arg> is an argument you want to pass through to K.
    "
    exit 0
fi

if [[ "$run_command" == 'version' ]] || [[ "$run_command" == '--version' ]] ; then
    echo "${KETC} version"
    cat  "$INSTALL_LIB"/version
    krun --version
    exit 0
fi

backend="llvm"
mode=NORMAL
cpuid1=0
cpuid2=0
feat=0

args=()
while [[ $# -gt 0 ]] ; do
    case "$1" in
        --mode)          mode="$2"                   ; shift 2 ;;
        --cpuid1)        cpuid1="$2"                 ; shift 2 ;;
        --cpuid2)        cpuid2="$2"                 ; shift 2 ;;
        --feat)          feat="$2"                   ; shift 2 ;;
        --backend)       backend="$2"                ; shift 2 ;;
        --directory)     backend_dir="$2"            ; shift 2 ;;
        --debug)         debug=true   ; args+=("$1") ; shift   ;;
        --verbose)       verbose=true ; args+=("$1") ; shift   ;;
        *)               args+=("$1")                ; shift   ;;
    esac
done

[[ "${#args[@]}" -le 0 ]] || set -- "${args[@]}"
backend_dir="${backend_dir:-$INSTALL_LIB/$backend}"

[[ "$backend" == llvm ]]           \
    || [[ "$backend" == haskell ]] \
    || fatal "Only the LLVM backend is currently supported."
[[ "$mode" == NORMAL  ]] || fatal "Only NORMAL mode is currently supported."

# get the run file
run_file="$1" ; shift
if [[ "${run_file}" == '-' ]] ; then
    tmp_input="$(mktemp)"
    trap "rm -rf ${tmp_input}" INT TERM EXIT
    cat - > "${tmp_input}"
    run_file="${tmp_input}"
fi
[[ -f "${run_file}" ]] || fatal "File does not exist: ${run_file}"

! ${debug} || set -x

case "$run_command-$backend" in
    run-@(llvm|haskell)     ) run_krun "$@"    ;;
    kompile-@(llvm|haskell) ) run_kompile "$@" ;;
    *) ${KETC} help ; fatal "Unknown command-backend combination: $run_command-$backend" ;;
esac
